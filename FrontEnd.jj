PARSER_BEGIN(FrontEnd)
    public class FrontEnd {
        public static void main(String[] args){

        }
    }
PARSER_END(FrontEnd)

/*Token*/

var, const, return, integer, boolean,
void, main, if, else, true, false, while and skip.

TOKEN: { /* Keywords */
    < VAR : "var" >
    | < CONST : "const" >
    | < RETURN : "return" >
    | < BOOLEAN : "boolean" >
    | < VOID : "void" >
    | < MAIN : "main" >
    | < IF : "if" >
    | < ELSE : "else" >
    | < TRUE : "true" >
    | < FALSE : "false" >
    | < WHILE : "while" >
    | < SKIP : "skip" >
}

TOKEN: {    /* Punctuation */ 
    < COMMA : "," >
    | < SEMIC : ";" >
    | < COLON : ":" >
    | < ASSIGN : "=" >
    | < LBRACE : "{" >
    | < RBRACE : "}" >
    | < LBRACKET : "(" >
    | < RBRACKET : ")" >
    | < PLUS_SIGN : "+" >
    | < MINUS_SIGN : "-" >
    | < TILDE : "~" >
    | < OR : "||" >
    | < AND : "&&" >
    | < EQUIV : "==" >
    | < NOTEQUIV : "!=" >
    | < LTHAN : "<" >
    | < GTHAN : ">" >
    | < LETHAN : "<=" >
    | < GETHAN : ">=" >
}

TOKEN: { /* Numbers and identifiers */
      < #DIGIT : ["0"-"9"] >
    | < #CHAR : ["aA"-"zZ"] >
    | < INTEGER : (<MINUS_SIGN>)? ["1"-"9"] (<DIGIT>)* | "0" >
    | < ID : (<CHAR>) (<CHAR><DIGIT>)* "_"* >
}

TOKEN_MGR_DECLS :
{
    static int commentNesting = 0;
}

SKIP : { /*Ignore whitespaces*/
    | " "
    | "\t"
    | "\n"
}

SKIP : {
    < "//" (<CHAR> | <DIGIT>)* *("\n" | "\r" | "\r\n") >
    | "/*" { commentNesting++; } : IN_COMMENT
}

<IN_COMMENT> SKIP : {
    | "/*" {commentNesting++; }
    | "*/" {commentNesting--; 
            if (commentNesting == 0)
                SwitchTo(DEFAULT);
            }
    | <~[]>
}

void Program(): {}
{
    (DeclList() FunctionList() <MAIN>)
}

void DeclList(): {}
{
    (Decl() [<SEMIC> DeclList()])?
}

void Decl(): {}
{
    VarDecl()
    | ConstDecl()
}

void VarDecl(): {}
{
    (<VAR> <ID> <COLON> Type())
}

void ConstDecl(): {}
{
    (<CONST> <ID> <COLON> Type() <ASSIGN> Expression())
}

void FunctionList(): {}
{
    (Function() FunctionList())?
}

void Function(): {}
{
    Type() <ID> <LBRACKET> ParameterList() <RBRACKET> 
    <LBRACE>
    DeclList()
    <RBRACE>
    StatementBlock() 
    <RETURN> <LBRACKET> (Expression())? <RBRACKET><SEMIC>
    <RBRACE>
}

void Type(): {}
{
    <INTEGER>
    | <BOOLEAN>
    | <VOID>
}

void ParameterList(): {}
{
    (NempParameterList())?
}

void NempParameterList(): {}
{
     <ID> <COLON> Type()
    |<ID> <COLON> Type() <COMMA> NempParameterList()
}

void Main(): {}
{
    <MAIN> <LBRACE>
    DeclList()
    StatementBlock()
    <RBRACE>
}

void StatementBlock(): {}
{
    (Statement() StatementBlock())?
}

void Statement(): {}
{
    <ID> <ASSIGN> Expression() <SEMIC>
    | <ID> <LBRACKET> ArgList() <RBRACKET> <SEMIC>
    | <LBRACE> StatementBlock() <RBRACE>
    | <IF> Condition() <LBRACE> StatementBlock() <RBRACE> <ELSE> <LBRACE> StatementBlock() <RBRACE>
    | <WHILE> Condition() <LBRACE> StatementBlock() <RBRACE>
    | <SKIP> <SEMIC>
}

void Expression(): {}
{
    Fragment() BinaryArithOp() Fragment()
    | <LBRACKET> Expression() <RBRACKET>
    | <ID> <LBRACKET> ArgList() <RBRACKET>
    | Fragment()
}

void BinaryArithOp(): {}
{
    <PLUS_SIGN> 
    | <MINUS_SIGN>
}

void Fragment(): {}
{
    <ID>
    | <MINUS_SIGN> <ID>
    | <DIGIT>
    | <TRUE>
    | <FALSE>
    | Expression()
}

void Condition(): {}
{
    <TILDE> Condition() 
    | <LBRACKET> Condition() <RBRACKET> 
    | Expression() CompOp() Expression()
    | Condition() (<OR> | <AND>) Condition()
}

void CompOp(): {}
{
    <EQUIV>
    | <NOTEQUIV>
    | <LTHAN>
    | <LETHAN
    | <GTHAN>
    | <GETHAN>
}

void ArgList(): {}
{
    (NempArgList())?
}

void NempArgList(): {}
{
    <ID>
    | <ID> <COMMA> (NempArgList())
}