/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. BackEnd.jj */
/*@egen*/options { 
    IGNORE_CASE = true;
                             
                 
    DEBUG_TOKEN_MANAGER = false;
}

PARSER_BEGIN(BackEnd)
    public class BackEnd/*@bgen(jjtree)*/implements BackEndTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected static JJTBackEndState jjtree = new JJTBackEndState();

/*@egen*/
        public static void main(String[] args){
            BackEnd parser;
            if (args.length == 1) {
                System.out.println("BackEnd Parser: Reading from file " + args[0] + " . . .");
                try {
                    parser = new BackEnd(new java.io.FileInputStream(args[0]));
                } catch (java.io.FileNotFoundException e) {
                    System.out.println("BackEnd Parser: File " + args[0] + " not found.");
                    return;
                }
            } else {
                    System.out.println("BackEnd Parser: Usage is one of:");
                    System.out.println(" java BackEndParser < inputfile");
                    System.out.println("OR");
                    System.out.println(" java BackEndParser inputfile");
                    return;
            } 
            try {
                SimpleNode root = parser.Program();
                root.dump("");
                System.out.println("CCAL Parser: CCAL program parsed successfully.");
                } catch (ParseException e) {
                System.out.println(e.getMessage());
                System.out.println("CCAL Parser: Encountered errors during parse.");
            }
        }
    }
PARSER_END(BackEnd)

/*Token*/

TOKEN: { /* Keywords */
    < VAR : "var" >
    | < CONST : "const" >
    | < RETURN : "return" >
    | < BOOLEAN : "boolean" >
    | < VOID : "void" >
    | < MAIN : "main" >
    | < IF : "if" >
    | < ELSE : "else" >
    | < TRUE : "true" >
    | < FALSE : "false" >
    | < WHILE : "while" >
    | < SKP : "skip" >
    | < INTEGER : "integer">
}

TOKEN: {    /* Punctuation */ 
    < COMMA : "," >
    | < SEMIC : ";" >
    | < COLON : ":" >
    | < ASSIGN : "=" >
    | < LBRC : "{" >
    | < RBRC : "}" >
    | < LPAR : "(" >
    | < RPAR : ")" >
    | < PLUS_SIGN : "+" >
    | < MINUS_SIGN : "-" >
    | < TILDE : "~" >
    | < OR : "||" >
    | < AND : "&&" >
    | < EQUIV : "==" >
    | < NOTEQUIV : "!=" >
    | < LTHAN : "<" >
    | < GTHAN : ">" >
    | < LETHAN : "<=" >
    | < GETHAN : ">=" >
}

TOKEN: { /* Numbers and identifiers */
      < #DIGIT : ["0"-"9"] >
    | < #CHAR : ["a"-"z", "A"-"Z"] >
    | < NUMBER : ("-")* ["1"-"9"] (<DIGIT>)* | "0" >
    | < ID : <CHAR> (<CHAR>| "_" | <DIGIT>)* >
}

TOKEN_MGR_DECLS :
{
    static int commentNesting = 0;
}

SKIP : { /*Ignore whitespaces*/
     " "
    | "\t"
    | "\n"
    | "\f"
    | "\r"
}

SKIP : {
    < "//" ([" " - "~"])* ("\n" | "\r" | "\r\n") >
    | "/*" { commentNesting++; } : IN_COMMENT
}

<IN_COMMENT> SKIP : {
      "/*" {commentNesting++; }
    | "*/" {commentNesting--; 
            if (commentNesting == 0)
                SwitchTo(DEFAULT);
            }
    | <~[]>
}

SimpleNode Program()         : {/*@bgen(jjtree) Program */
  ASTProgram jjtn000 = new ASTProgram(JJTPROGRAM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Program */
    try {
/*@egen*/
    DeclList() FunctionList() Main() <EOF>/*@bgen(jjtree)*/
                                           {
                                             jjtree.closeNodeScope(jjtn000, true);
                                             jjtc000 = false;
                                           }
/*@egen*/ {return jjtn000;}/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void DeclList(): {}
{
    Decl() <SEMIC> DeclList() 
    | {}
}

void Decl(): {}
{
    VarDecl()
    | ConstDecl()
}

void VarDecl()     : {/*@bgen(jjtree) Var */
                      ASTVar jjtn000 = new ASTVar(JJTVAR);
                      boolean jjtc000 = true;
                      jjtree.openNodeScope(jjtn000);
/*@egen*/Token t; String id; String type;} 
{/*@bgen(jjtree) Var */
    try {
/*@egen*/
    t = <VAR> id = Id() <COLON> type = Type()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ConstDecl()       : {/*@bgen(jjtree) Const */
                          ASTConst jjtn000 = new ASTConst(JJTCONST);
                          boolean jjtc000 = true;
                          jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) Const */
    try {
/*@egen*/
    t = <CONST> Id() <COLON> Type() <ASSIGN> Expression()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void FunctionList(): {}
{
    Function() FunctionList()
    | {}
}

void Function()      : {/*@bgen(jjtree) Func */
  ASTFunc jjtn000 = new ASTFunc(JJTFUNC);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Func */
    try {
/*@egen*/
    Type() Id() <LPAR> ParameterList() <RPAR> 
    <LBRC> 
    DeclList() StatementBlock() 
    <RETURN> <LPAR> (Expression() | {}) <RPAR> <SEMIC> 
    <RBRC>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

String Type()      : {/*@bgen(jjtree) Type */
                      ASTType jjtn000 = new ASTType(JJTTYPE);
                      boolean jjtc000 = true;
                      jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) Type */
    try {
/*@egen*/
    t = <INTEGER>/*@bgen(jjtree)*/
                  {
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                  }
/*@egen*/ {jjtn000.value = t.image; return t.image;}
    | t = <BOOLEAN>/*@bgen(jjtree)*/
                    {
                      jjtree.closeNodeScope(jjtn000, true);
                      jjtc000 = false;
                    }
/*@egen*/ {jjtn000.value = t.image; return t.image;}
    | t = <VOID>/*@bgen(jjtree)*/
                 {
                   jjtree.closeNodeScope(jjtn000, true);
                   jjtc000 = false;
                 }
/*@egen*/ {jjtn000.value = t.image; return t.image;}/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ParameterList(): {}
{
    NempParameterList()
    | {}
}

void NempParameterList()           : {/*@bgen(jjtree) NempParam */
  ASTNempParam jjtn000 = new ASTNempParam(JJTNEMPPARAM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) NempParam */
    try {
/*@egen*/
    Id() <COLON> Type() (<COMMA> NempParameterList() |/*@bgen(jjtree)*/
                                                       {
                                                         jjtree.closeNodeScope(jjtn000, true);
                                                         jjtc000 = false;
                                                       }
/*@egen*/ {})/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Main()      : {/*@bgen(jjtree) Main */
  ASTMain jjtn000 = new ASTMain(JJTMAIN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Main */
    try {
/*@egen*/
    <MAIN> <LBRC> 
    DeclList() StatementBlock() 
    <RBRC>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void StatementBlock(): {}
{
    (Statement() StatementBlock())
    | {}
}

void Statement()           : {/*@bgen(jjtree) Statement */
  ASTStatement jjtn000 = new ASTStatement(JJTSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Statement */
    try {
/*@egen*/
    Id() (<ASSIGN> Expression() <SEMIC> | <LPAR> ArgList() <RPAR> <SEMIC>)
    | <LBRC> StatementBlock() <RBRC>/*@bgen(jjtree)*/
                                    {
                                      jjtree.closeNodeScope(jjtn000, true);
                                      jjtc000 = false;
                                    }
/*@egen*/{}
    | <IF> Condition() <LBRC> StatementBlock() <RBRC> <ELSE> <LBRC> StatementBlock() <RBRC>
    | <WHILE> Condition() <LBRC> StatementBlock() <RBRC>
    | <SKP> <SEMIC>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Expression(): {}
{
     Fragment() (BinaryArithOp() Fragment() | {})
    | <LPAR> Expression() <RPAR> 
}

void BinaryArithOp(): {Token t;}
{
    t = <PLUS_SIGN>/*@bgen(jjtree) Plus */
                    {
                      ASTPlus jjtn001 = new ASTPlus(JJTPLUS);
                      boolean jjtc001 = true;
                      jjtree.openNodeScope(jjtn001);
                    }
                    try {
/*@egen*//*@bgen(jjtree)*/
                    {
                      jjtree.closeNodeScope(jjtn001, true);
                      jjtc001 = false;
                    }
/*@egen*/ {jjtn001.value = t.image;}/*@bgen(jjtree)*/
                    } finally {
                      if (jjtc001) {
                        jjtree.closeNodeScope(jjtn001, true);
                      }
                    }
/*@egen*/       
    | t = <MINUS_SIGN>/*@bgen(jjtree) Minus */
                       {
                         ASTMinus jjtn002 = new ASTMinus(JJTMINUS);
                         boolean jjtc002 = true;
                         jjtree.openNodeScope(jjtn002);
                       }
                       try {
/*@egen*//*@bgen(jjtree)*/
                       {
                         jjtree.closeNodeScope(jjtn002, true);
                         jjtc002 = false;
                       }
/*@egen*/ {jjtn002.value = t.image;}/*@bgen(jjtree)*/
                       } finally {
                         if (jjtc002) {
                           jjtree.closeNodeScope(jjtn002, true);
                         }
                       }
/*@egen*/       
}

void Fragment(): {}
{
    (<MINUS_SIGN> | {}) Id() (<LPAR> ArgList() <RPAR> | {}) FragmentPrime()
    | Num() FragmentPrime()
    | Bool() FragmentPrime()
}

void FragmentPrime(): {}
{
    BinaryArithOp() Expression() FragmentPrime()
    | {}
}

void Condition(): {}
{ 
     <TILDE> Condition() ConditionPrime()
    | <LPAR> Condition() <RPAR> ConditionPrime()
    | Fragment() CompOp() Expression() ConditionPrime()
}

void ConditionPrime(): {}
{
    (<OR> | <AND>) Condition() ConditionPrime()
    | {}
}

void CompOp(): {Token t;}
{
    t = <EQUIV>/*@bgen(jjtree) Equiv */
                {
                  ASTEquiv jjtn001 = new ASTEquiv(JJTEQUIV);
                  boolean jjtc001 = true;
                  jjtree.openNodeScope(jjtn001);
                }
                try {
/*@egen*//*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn001, true);
                  jjtc001 = false;
                }
/*@egen*/ {jjtn001.value = t.image;}/*@bgen(jjtree)*/
                } finally {
                  if (jjtc001) {
                    jjtree.closeNodeScope(jjtn001, true);
                  }
                }
/*@egen*/       
    | t = <NOTEQUIV>/*@bgen(jjtree) NotEquiv */
                     {
                       ASTNotEquiv jjtn002 = new ASTNotEquiv(JJTNOTEQUIV);
                       boolean jjtc002 = true;
                       jjtree.openNodeScope(jjtn002);
                     }
                     try {
/*@egen*//*@bgen(jjtree)*/
                     {
                       jjtree.closeNodeScope(jjtn002, true);
                       jjtc002 = false;
                     }
/*@egen*/ {jjtn002.value = t.image;}/*@bgen(jjtree)*/
                     } finally {
                       if (jjtc002) {
                         jjtree.closeNodeScope(jjtn002, true);
                       }
                     }
/*@egen*/           
    | t = <LTHAN>/*@bgen(jjtree) LThan */
                  {
                    ASTLThan jjtn003 = new ASTLThan(JJTLTHAN);
                    boolean jjtc003 = true;
                    jjtree.openNodeScope(jjtn003);
                  }
                  try {
/*@egen*//*@bgen(jjtree)*/
                  {
                    jjtree.closeNodeScope(jjtn003, true);
                    jjtc003 = false;
                  }
/*@egen*/ {jjtn003.value = t.image;}/*@bgen(jjtree)*/
                  } finally {
                    if (jjtc003) {
                      jjtree.closeNodeScope(jjtn003, true);
                    }
                  }
/*@egen*/       
    | t = <LETHAN>/*@bgen(jjtree) LEThan */
                   {
                     ASTLEThan jjtn004 = new ASTLEThan(JJTLETHAN);
                     boolean jjtc004 = true;
                     jjtree.openNodeScope(jjtn004);
                   }
                   try {
/*@egen*//*@bgen(jjtree)*/
                   {
                     jjtree.closeNodeScope(jjtn004, true);
                     jjtc004 = false;
                   }
/*@egen*/ {jjtn004.value = t.image;}/*@bgen(jjtree)*/
                   } finally {
                     if (jjtc004) {
                       jjtree.closeNodeScope(jjtn004, true);
                     }
                   }
/*@egen*/        
    | t = <GTHAN>/*@bgen(jjtree) GThan */
                  {
                    ASTGThan jjtn005 = new ASTGThan(JJTGTHAN);
                    boolean jjtc005 = true;
                    jjtree.openNodeScope(jjtn005);
                  }
                  try {
/*@egen*//*@bgen(jjtree)*/
                  {
                    jjtree.closeNodeScope(jjtn005, true);
                    jjtc005 = false;
                  }
/*@egen*/ {jjtn005.value = t.image;}/*@bgen(jjtree)*/
                  } finally {
                    if (jjtc005) {
                      jjtree.closeNodeScope(jjtn005, true);
                    }
                  }
/*@egen*/       
    | t = <GETHAN>/*@bgen(jjtree) GEThan */
                   {
                     ASTGEThan jjtn006 = new ASTGEThan(JJTGETHAN);
                     boolean jjtc006 = true;
                     jjtree.openNodeScope(jjtn006);
                   }
                   try {
/*@egen*//*@bgen(jjtree)*/
                   {
                     jjtree.closeNodeScope(jjtn006, true);
                     jjtc006 = false;
                   }
/*@egen*/ {jjtn006.value = t.image;}/*@bgen(jjtree)*/
                   } finally {
                     if (jjtc006) {
                       jjtree.closeNodeScope(jjtn006, true);
                     }
                   }
/*@egen*/        
}

void ArgList()         : {/*@bgen(jjtree) ArgList */
  ASTArgList jjtn000 = new ASTArgList(JJTARGLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ArgList */
    try {
/*@egen*/
    NempArgList()
    |/*@bgen(jjtree)*/
      {
        jjtree.closeNodeScope(jjtn000, true);
        jjtc000 = false;
      }
/*@egen*/ {}/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void NempArgList(): {}
{
    Id() (<COMMA> NempArgList() | {})
}

String Id()    : {/*@bgen(jjtree) Id */
                  ASTId jjtn000 = new ASTId(JJTID);
                  boolean jjtc000 = true;
                  jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) Id */
    try {
/*@egen*/
    t = <ID>/*@bgen(jjtree)*/
             {
               jjtree.closeNodeScope(jjtn000, true);
               jjtc000 = false;
             }
/*@egen*/ {jjtn000.value = t.image; return t.image;}/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

String Num()     : {/*@bgen(jjtree) Num */
                    ASTNum jjtn000 = new ASTNum(JJTNUM);
                    boolean jjtc000 = true;
                    jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) Num */
    try {
/*@egen*/
    t = <NUMBER>/*@bgen(jjtree)*/
                 {
                   jjtree.closeNodeScope(jjtn000, true);
                   jjtc000 = false;
                 }
/*@egen*/ {jjtn000.value = t.image;}/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

String Bool()      : {/*@bgen(jjtree) Bool */
                      ASTBool jjtn000 = new ASTBool(JJTBOOL);
                      boolean jjtc000 = true;
                      jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) Bool */
    try {
/*@egen*/
    t = <TRUE>/*@bgen(jjtree)*/
               {
                 jjtree.closeNodeScope(jjtn000, true);
                 jjtc000 = false;
               }
/*@egen*/ {jjtn000.value = t.image;}
    | t = <FALSE>/*@bgen(jjtree)*/
                  {
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                  }
/*@egen*/ {jjtn000.value = t.image;}/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}